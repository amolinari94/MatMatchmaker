@page "/MatchViewer"
@using Microsoft.AspNetCore.Components
@using System.Diagnostics
@using Structure
@using System.ComponentModel.DataAnnotations.Schema
@using System.Reflection.Metadata
@rendermode InteractiveServer


<h3>MatchViewer</h3>




<div>
    <table class="table" style="caption-side: top; width: auto; height: 20px; text-align: center; margin-left: auto; margin-right: auto; border-collapse: separate; border-radius: 20px; border-color: rgb(227,227,227); " ondragover="event.preventDefault();">
        <caption  class="main-title" style=" text-align: center !important; display: table-caption !important;  font-family: 'Helvetica Neue',serif;  border-top-style: none; border-right: none">
            <div style=" background:none;  text-align: center; border-radius: 20px;">Matches</div>
        </caption>
        
        <tbody>
        @foreach (var item in matches.OrderBy(x => x.Order)) {

            <tr style="@elementStyle" @key="item"  @ondragstart="() => { draggingMatch = item; displayColor(true); }" @ondragend="() => { draggingMatch = null; displayColor(false); }" draggable="true" @ondrop="() => HandleDrop(item)">

                <td style="@elementStyle">@(item.Order)</td>
                <td style="@elementStyle">@item.Name@*.match[0].firstName</td>
                        <td>@item.match[0].gender</td>
                        <td>@item.match[0].weight</td>
                        <td>@item.match[0].skill</td>
                        <td>@item.match[0].grade*@</td>
                <td><button style="height: 50%; vertical-align: bottom;" content="▼" @onclick="(()=> shiftDown(item))"></button><button style="height: 50%; vertical-align: top;" content="▲" @onclick="(()=> shiftUp(item))" ></button> </td>




            </tr>


        }

        </tbody>
    </table>
        </div>





@code {
    
    public string lastName { get; set; }
    public string firstName { get; set; }
    public string skill { get; set; }
    public string grade { get; set; }
    public string gender { get; set; }
    public string schoolName { get; set; }
    public bool matchschool {get;set; }
    
    public int diff {get;set;}

    public int skillDiff{get;set;}

    public int gradeDiff {get;set;}

    public int weightMax {get;set;}

    public int weightMin{get;set;}
    public int index=0;
     private List<Model> Models { get; } = [];

     private void shiftDown(Match match) {
         if (match.Order < matches.Count) {
             //Match temp = matches.ToList()[match.Order + 1];
             matches.ToList()[match.Order].Order--;
             match.Order++;
         }
         
         
     }
     
     private void shiftUp(Match match) {
         if (match.Order > 1) {
             //match.Order--;
             Match temp = matches.ToList()[match.Order - 1];
             temp.Order++;
             match.Order--;
             matches.ToList()[match.Order + 1] = temp;
             
         }
         
     }
     
     

     private class Model
     {
         public int Order { get; set; }
         public string Name { get; set; } = "";
         public bool IsDragOver { get; set; }
         @*protected internal Wrestler[] match {get;set;}=[];*@
     }
     
     private Model? draggingModel;//the model that is being dragged
     private Match? draggingMatch;
     LinkedList<Match> matches = new LinkedList<Match>();
     protected override void OnInitialized() {//fill names wit "random" string
         
         
         for (int i = 1; i <= 5; i++) // Assuming you want 5 test matches
         {
             matches.AddLast(new Match
             {
                 Order = i,
                 Name = $"firstnameTest{i} lastnameTest{i} vs firstnameTest{i + 1} lastnameTest{i + 1}",
                 //IsDragOver = false
             });
             
             
         }
         
         
         /*
         for (var i = 0; i < 10 @*testEvent.matchList.Length*@; i++)
         {
             Model m = new() { Order = i, Name = $"Item {i}"@*, match=testEvent.matchList[i]*@};
             Models.Add(m);
         }
         */
         
         base.OnInitialized();
     }

     private string elementStyle = "";
     private void displayColor(bool condition) {
         if (condition) {
             elementStyle = "background-color: #7eb1de; border: solid; border-radius: 20px; border-color: #0E88AE;";
         }
         else {
             elementStyle = "";
         }
         
     }
     private void HandleDrop(Match landingMatch)
     {//landing model -> where the drag happened
		
		
         if (draggingMatch is null)
         {
             Console.WriteLine("Null issue");
             return;
			
         }
		
         int originalOrderLanding = landingMatch.Order;//keep the original order for later
         //increase model uned by 1
         matches.Where(x => x.Order >= landingMatch.Order).ToList().ForEach(x => x.Order++);
         draggingMatch.Order = originalOrderLanding;//replace landing model
         int ii = 1;//used to be 0 
         foreach (var model in matches.OrderBy(x => x.Order).ToList())
         {
             model.Order = ii++;//keep the numbers from 0 to size-1
             model.IsDragOver = false;//remove drag over.
         }
     }


     public void addMatch(School school1, School school2) {
         Wrestler[] match = new Wrestler[2];
         Wrestler first;
         Structure.Roster roster1 = school1.roster;
         Structure.Roster roster2 = school2.roster;
         foreach (var item in roster1.rosterList) {
             if (item.Value.weight <= weightMin || item.Value.weight >= weightMax) {
                 continue;
             }

             first = item.Value;

             foreach (var item2 in roster2.rosterList) {

                 Wrestler second = item2.Value;
                 if (second.weight <= weightMin || second.weight >= weightMax) {
                     continue;
                 }

                 //Checks to see if the people are not the same gender, and if not, checks if either wrestler can't wrestle the other gender
                 if (first.gender != second.gender && (!first.sameGenderOnly || !second.sameGenderOnly)) {
                     continue;
                 }

                 if (Math.Abs(second.weight - first.weight) > diff) {
                     continue;
                 }

                 if (Math.Abs(second.grade - first.grade) > gradeDiff) {
                     continue;
                 }

                 if (Math.Abs(second.skillLevel - first.skillLevel) > skillDiff) {
                     continue;
                 }

                 match.Append(first);
                 match.Append(second);
             }

         }
     }

}